
#include "Sensor_AR0135.h"

CSensor_AR0135::CSensor_AR0135()
{

}
void CSensor_AR0135::SetUsbHandle(cyusb_handle *pUsbHandle)
{
	m_pUsbHandle=pUsbHandle;
}


cq_int32_t CSensor_AR0135::WrSensorReg(const cq_uint16_t iAddr, const cq_uint16_t iValue)
{
    cq_uint8_t data[10]={'0'};//no use, just to make firmware happy
    return cyusb_control_write(m_pUsbHandle, 0x40, 0xf1, iValue, iAddr, data, 2, 100);
}


cq_int32_t CSensor_AR0135::RdSensorReg(const cq_uint16_t iAddr, cq_uint8_t &	iValue)
{
	return cyusb_control_read(m_pUsbHandle, 0x40, 0xf2,0x0, iAddr, &iValue, 2, 100);
}


cq_int32_t CSensor_AR0135::WrFpgaReg(const cq_uint8_t iAddr, const cq_uint8_t iValue)
{
    cq_uint8_t data[10]={'0'};//no use, just to make firmware happy
    return cyusb_control_write(m_pUsbHandle, 0x40, 0xf3, iValue, iAddr, data, 1, 100);
}


cq_int32_t CSensor_AR0135::RdFpgaReg(const cq_uint8_t iAddr, cq_uint8_t &iValue)
{
    return cyusb_control_read(m_pUsbHandle, 0x40, 0xf4, 0x0, iAddr, &iValue, 1, 100);
}

cq_int32_t CSensor_AR0135::InitSensor()
{
    //cq_uint8_t data[64]={'0'};//no use, just to make firmware happy
    //cq_int32_t r = cyusb_control_write(m_pUsbHandle,0x40,0xf0,0,0,data,2,100);
    
    WrSensorReg(0x3028,0x0010);//0		ROW_SPEED = 16
	WrSensorReg(0x302A,0x000C);//1		VT_PIX_CLK_DIV = 12   P2   4<=P2<=16
	WrSensorReg(0x302C,0x0001);//2		VT_SYS_CLK_DIV = 1    P1   1<=P1<=16
	WrSensorReg(0x302E,0x0001);//3		PRE_PLL_CLK_DIV = 2   N    1<=N<=63
	WrSensorReg(0x3030,0x0020);//4		PLL_MULTIPLIER = 40   M   32<=M<=255

	WrSensorReg(0x3032,0x0000);//5		DIGITAL_BINNING = 0   _BINNING  帧率降一半
	WrSensorReg(0x30B0,0x0080);//6		DIGITAL_TEST = 128

	WrSensorReg(0x301A,0x00D8);//8		RESET_REGISTER = 216
	WrSensorReg(0x301A,0x10DC);//9		RESET_REGISTER = 4316  h10DC    关键寄存器

	WrSensorReg(0x3002,0x007C);//10	Y_ADDR_START = 124
	WrSensorReg(0x3004,0x0002);//11	X_ADDR_START = 2
	WrSensorReg(0x3006,0x034B);//12	Y_ADDR_END = 843
	WrSensorReg(0x3008,0x0501);//13	X_ADDR_END = 1281

	WrSensorReg(0x300A,0x02FD);//14	FRAME_LENGTH_LINES = 837
	WrSensorReg(0x300C,0x056C);//15	LINE_LENGTH_PCK = 1388

	WrSensorReg(0x3012,0x0080);//16	COARSE_INTEGRATION_TIME = 252	 h00FC	曝光时间
	WrSensorReg(0x3014,0x008D);//17	FINE_INTEGRATION_TIME = 233

	WrSensorReg(0x30A6,0x0001);//18	Y_ODD_INC = 1			    SKIP模式

	WrSensorReg(0x3040,0x0000);//27	READ_MODE = 0			镜像等

	WrSensorReg(0x3064,0x1982);//28	EMBEDDED_DATA_CTRL = 6530    开启输出 两行寄存器值 和  EMBEDDED_DATA  ，如果用AE模式 ，必须得开。图像输出时前两行不读

	WrSensorReg(0x3100,0x0003);//30	AE;AG

	WrSensorReg(0x305E,0x003C);//29	Total gain

	WrSensorReg(0x3046,0x0100);
    
    return 0;
}


cq_int32_t CSensor_AR0135::SetAnalogGain(const cq_uint8_t chTrigType, const cq_uint8_t chGainType)
{
	cq_int32_t r=0;
	switch(chTrigType) 
	{   
		case TRIGMODE_AUTO:
		{
			switch(chGainType)
			{
				case ANALOGGAIN_1X:
					r=WrSensorReg(0x30B0,0x0080);
					break;
				case ANALOGGAIN_2X:
					r=WrSensorReg(0x30B0,0x0090);
					break;
				case ANALOGGAIN_4X:
					r=WrSensorReg(0x30B0,0x00A0);
					break;
				case ANALOGGAIN_8X:
					r=WrSensorReg(0x30B0,0x00B0);
					break;
				default:
					r=-99;
					break;
			}
			break;	
		}
		case TRIGMODE_FPGA:
		{
			switch(chGainType)
			{
				case ANALOGGAIN_1X:
					r=WrSensorReg(0x30B0,0x0480);
					break;
				case ANALOGGAIN_2X:
					r=WrSensorReg(0x30B0,0x0490);
					break;
				case ANALOGGAIN_4X:
					r=WrSensorReg(0x30B0,0x04A0);
					break;
				case ANALOGGAIN_8X:
					r=WrSensorReg(0x30B0,0x04B0);
					break;
				default:
					r=-99;
					break;	
			}
			break;
		}	
		default:
			r=-99;
			break;	
	}
	return r;
}


cq_int32_t CSensor_AR0135::SetFpgaTrigFreq(const cq_uint8_t iFreqVal)
{
     cq_int32_t r=WrFpgaReg(0x05, iFreqVal&0xff);
     return r;
}
	
cq_int32_t CSensor_AR0135::SetTrigMode(const cq_uint8_t chTrigType)
{
	switch(chTrigType)
	{
		case TRIGMODE_AUTO:
			WrSensorReg(0x30B0, 0x0080);
			WrSensorReg(0x301A, 0x10DC);
			WrFpgaReg(0x00, 0x00);
			break;
		case TRIGMODE_FPGA:
			WrSensorReg(0x30B0, 0x0480);
			WrSensorReg(0x301A, 0x19D8);
			WrFpgaReg(0x00, 0x01);
			WrFpgaReg(0x05, 0x01);// 0x01 by default
			break;
		default:
			break;
	}
	return 0;

}


cq_int32_t CSensor_AR0135::SetExpoValue(const cq_uint16_t iExpoVal)
{
	cq_int32_t r=WrSensorReg(0x3012, iExpoVal);
	return r;

}

cq_int32_t CSensor_AR0135::SetGainValue(const cq_uint16_t iGainVal)
{
    cq_int32_t r=WrSensorReg(0x305E, iGainVal);
    return r;
}

cq_int32_t CSensor_AR0135::SetAutoGainExpo(const cq_bool_t bIsAutoGain, const cq_bool_t bIsAutoExpo)
{
    if((bIsAutoGain==true)&&(bIsAutoExpo==true))
       return WrSensorReg(0x3100, 0x0003);

    if ((bIsAutoGain==true)&&(bIsAutoExpo==false))
       return WrSensorReg(0x3100, 0x0002);

    if ((bIsAutoGain==false)&&(bIsAutoExpo==true))
       return WrSensorReg(0x3100, 0x0001);

    if ((bIsAutoGain==false)&&(bIsAutoExpo==false))
       return WrSensorReg(0x3100, 0x0000);
	return -99;//should never reach here
}



cq_int32_t CSensor_AR0135::SetResolution(const cq_uint8_t chResoluType)
{
	switch(chResoluType)
	{
		case RESOLU_1280_720:
			WrSensorReg(0x3030, 0x0020);
			WrSensorReg(0x3002, 0x007C);
			WrSensorReg(0x3004, 0x0002);
			WrSensorReg(0x3006, 0x034B);
			WrSensorReg(0x3008, 0x0501);
			WrSensorReg(0x300A, 0x02FD);
			WrSensorReg(0x300C, 0x056C);
			WrSensorReg(0x30A6, 0x0001);
			WrSensorReg(0x3032, 0x0000);// ¹Ø±ÕbiningÄ£Êœ

			WrFpgaReg(0x01, 0x05);
			WrFpgaReg(0x02, 0x00);
			WrFpgaReg(0x03, 0x02);
			WrFpgaReg(0x04, 0xd0);
			WrFpgaReg(0x06, 0x00);
			break;
		case RESOLU_1280_960:
			WrSensorReg(0x3030, 0x0020);
			WrSensorReg(0x3002, 0x0004);
			WrSensorReg(0x3004, 0x0002);
			WrSensorReg(0x3006, 0x03C3);
			WrSensorReg(0x3008, 0x0501);
			WrSensorReg(0x300A, 0x03FD);
			WrSensorReg(0x300C, 0x056C);
			WrSensorReg(0x30A6, 0x0001);
			WrSensorReg(0x3032, 0x0000);// ¹Ø±ÕbiningÄ£Êœ

			WrFpgaReg(0x01, 0x05);
			WrFpgaReg(0x02, 0x00);
			WrFpgaReg(0x03, 0x03);
			WrFpgaReg(0x04, 0xC0);
			WrFpgaReg(0x06, 0x00);
			break;
		case RESOLU_640_480_SKIP:	
			WrSensorReg(0x3030, 0x002A);
			WrSensorReg(0x3002, 0x0004);
			WrSensorReg(0x3004, 0x0002);
			WrSensorReg(0x3006, 0x03C3);
			WrSensorReg(0x3008, 0x0501);
			WrSensorReg(0x300A, 0x01FB);
			WrSensorReg(0x300C, 0x056C);
			WrSensorReg(0x30A6, 0x0003);
			WrSensorReg(0x3032, 0x0000);// ¹Ø±ÕbiningÄ£Êœ

			WrFpgaReg(0x01, 0x02);
			WrFpgaReg(0x02, 0x80);
			WrFpgaReg(0x03, 0x01);
			WrFpgaReg(0x04, 0xE0);
			WrFpgaReg(0x06, 0x01);					
			break;
		case RESOLU_640_480_BIN:
			WrSensorReg(0x3030, 0x0020);
			WrSensorReg(0x3002, 0x0004);
			WrSensorReg(0x3004, 0x0002);
			WrSensorReg(0x3006, 0x03C3);
			WrSensorReg(0x3008, 0x0501);
			WrSensorReg(0x300A, 0x03FB);
			WrSensorReg(0x300C, 0x056C);
			WrSensorReg(0x30A6, 0x0001);
			WrSensorReg(0x3032, 0x0002);// ¿ªÆôbinningÄ£Êœ

			WrFpgaReg(0x01, 0x02);
			WrFpgaReg(0x02, 0x80);
			WrFpgaReg(0x03, 0x01);
			WrFpgaReg(0x04, 0xE0);
			WrFpgaReg(0x06, 0x00);
		default:
			break;
	}
	return 0;
		

}


cq_int32_t CSensor_AR0135::SetMirrorType(const cq_uint8_t chMirrorType)
{
	if(MIRROR_NORMAL==chMirrorType)	//normal
		return WrSensorReg(0x3040, 0x0000);

	if(MIRROR_X==chMirrorType)//X
		return WrSensorReg(0x3040, 0x4000);

	if(MIRROR_Y==chMirrorType)//Y
		return WrSensorReg(0x3040, 0x8000);

	if(MIRROR_XY==chMirrorType)//XY
		return WrSensorReg(0x3040, 0xC000);

	return -99;//should never reach here

}


cq_int32_t CSensor_AR0135::SetBitDepth(const cq_uint8_t chBitDepthType)
{
	if(BITDEPTH_8==chBitDepthType)	//8
		return WrFpgaReg(0x7, 0x0);

	if(BITDEPTH_16==chBitDepthType)//16
		return WrFpgaReg(0x7, 0x1);

	if(BITDEPTH_16_2==chBitDepthType)//16
		return WrFpgaReg(0x7, 0x2);

	return -99;//should never reach here

}


cq_int32_t CSensor_AR0135::SendUsbSpeed2Fpga(const cq_uint8_t chSpeedType)
{
	return WrFpgaReg(0x08, chSpeedType);
}






